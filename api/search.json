[{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"\ntitle:NSSctf做题笔记tags:-ctf从 Nikto 扫描到获取 Shell 的完整解题思路梳理知识点： Nikto扫描 ，PUT文件上传 ,RCE一、核心线索链（从发现到利用的全流程）初始定位：通过 HTTP 请求包得知目标 node4.anna.nssctf.cn:28017，初步判断是 CTF Web &#x2F; 服务类题目；\n服务探测：nmap 扫描显示端口开放且标注为mongod，但后续 MongoDB 客户端连接失败（版本兼容 + 实际服务类型误判）；关键转折：curl 访问目标端口，发现实际是 Apache+PHP Web 服务（highlight_file(FILE) 暴露 PHP 环境）；漏洞挖掘：Nikto 扫描爆出核心漏洞 ——HTTP PUT 方法开启（允许客户端向服务器上传文件）；漏洞利用：利用 PUT 方法上传 PHP 脚本，先读取目标源码和目录结构，确认 flag 不在当前目录；优化脚本，上传支持 GET 参数的 PHP 一句话 Shell，通过?cmd&#x3D;xxx执行系统命令；最终通过 Shell 读取根目录 flag，完成解题。二、每一步的核心目的与逻辑\n\n服务探测阶段（nmap+curl）目的：明确目标端口对应的真实服务类型（避免被初始标注误导）；关键逻辑：nmap 标注mongod但客户端连接失败 → 怀疑服务类型误判；curl 直接访问端口 → 确认是 Web 服务（PHP 环境），推翻之前 MongoDB 的方向；核心结论：从 “数据库服务” 转向 “Web 服务漏洞利用”。\n漏洞扫描阶段（Nikto）目的：快速发现 Web 服务的潜在漏洞和配置缺陷；关键逻辑：Nikto 扫描重点关注 “高危可利用漏洞”，忽略单纯的安全配置问题（如缺失 X-Frame-Options 头）；锁定核心漏洞：HTTP PUT方法开启 → 直接突破点（可上传文件 &#x3D; 获取服务器操作权限）；补充信息：确认 Apache+PHP 版本（无已知高危版本漏洞，无需额外绕路）。\n漏洞利用阶段（PUT 上传 + Shell 构造）目的：通过 PUT 上传获取服务器权限，最终定位并读取 flag；分步骤逻辑：第一步：上传基础 PHP 脚本（读源码 + 列目录）→ 排查 flag 是否在当前目录 &#x2F; 源码中；第二步：排查无果后，上传支持 GET 参数的一句话 Shell → 灵活执行系统命令（突破当前目录限制）；第三步：通过 Shell 执行cat &#x2F;flag（CTF 根目录 flag 高频位置）→ 直接获取 flag；核心思路：从 “被动读取” 到 “主动执行”，逐步扩大操作范围。三、关键决策点与避坑总结\n避免 “标签误导”坑：nmap 标注mongod就死磕 MongoDB 客户端兼容问题；解：当客户端连接失败时，立刻用 curl &#x2F; 浏览器访问端口，验证是否为 Web 服务（端口可复用，标注不一定 100% 准确）。\n聚焦 “可利用漏洞”坑：被 Nikto 输出的大量信息干扰（如版本过时、配置缺失）；解：优先筛选 “能直接操作服务器” 的漏洞（如 PUT 上传、文件包含、命令执行），这类漏洞是 CTF 解题的 “捷径”。\n脚本构造 “从简到繁”坑：一开始写复杂脚本导致语法错误（如之前read_flag.php报错）；解：先上传极简脚本（如单行走读文件、列目录），验证功能正常后，再扩展为支持参数的 Shell（降低调试成本）。\n利用 “CTF 惯例” 缩短路径核心惯例：flag 常藏在&#x2F;flag（根目录无后缀）、&#x2F;flag.txt、当前目录flag.php；逻辑：无需盲目遍历全系统，先尝试高频位置，再通过 Shell 扩大范围（提高效率）。\n\n","slug":"NSSCTF","date":"2025-11-17T10:42:39.846Z","categories_index":"","tags_index":"","author_index":"Wclxd"},{"id":"d4ce15d0e6461839b152fd67cbb07148","title":"TCP协议基础","content":"什么是TCP协议（Transmission Control Protocol，传输控制协议）是一种面向连接、可靠的传输层协议，其核心是通过 “标志位控制”“序号与确认机制” 实现数据的有序、无差错传输。以下从 “TCP 协议基础结构”“发包与解包过程”“基于 TCP 的常见扫描原理” 三个维度展开说明：一、TCP 协议基础：首部结构与核心字段TCP 数据包的 “首部”（Header）包含控制通信的关键信息，固定部分 20 字节，可选部分最多 40 字节，核心字段如下（与发包、扫描相关的重点）：字段\t作用源端口 &#x2F; 目的端口\t标识发送端和接收端的应用程序（如 80 端口对应 HTTP，443 对应 HTTPS）。序号（Sequence Number）\t标记数据包的字节顺序，确保接收端按序重组（每发送 1 字节，序号 + 1）。确认号（Acknowledgment Number）\t期望收到的下一个字节序号（仅当 ACK 标志位为 1 时有效），用于确认已收到数据。数据偏移\t指示 TCP 首部长度（单位：32 位字，即 4 字节），区分首部和数据部分。标志位（Flags）\t6 个 1 位标志位，控制连接状态：\n\nSYN：发起连接请求；\nACK：确认收到数据；\nFIN：请求关闭连接；\nRST：强制重置连接；\nPSH：要求立即推送数据给应用层；\nURG：标记紧急数据。窗口大小\t接收端的缓冲区大小，用于流量控制（告诉发送端 “最多还能接收多少字节”）。校验和\t用于检测数据包在传输中是否损坏（首部 + 数据均参与计算）。\n\n\n二、TCP 的发包与解包过程TCP 的 “发包” 指发送端封装数据为 TCP 包并发送，“解包” 指接收端解析 TCP 包并提取数据，过程依赖操作系统的 TCP&#x2F;IP 协议栈（如 Linux 的tcp_v4_sendmsg、tcp_v4_rcv函数）：\n\n发包过程（发送端）步骤 1：应用层数据传递应用程序（如浏览器）通过socket接口向 TCP 层发送数据（例如 HTTP 请求）。步骤 2：TCP 层封装首部TCP 协议栈为数据添加首部：填充源端口（随机或指定）、目的端口（目标服务端口）；分配序号（初始序号 ISN 由系统随机生成，后续按字节递增）；根据通信状态设置标志位（如首次连接设 SYN&#x3D;1）；计算校验和（确保数据完整性）。步骤 3：IP 层与链路层封装TCP 包被传递到 IP 层，添加 IP 首部（源 IP、目的 IP 等），再传递到链路层（如以太网）添加 MAC 首部，最终通过物理层（网线、无线）发送。\n解包过程（接收端）步骤 1：链路层与 IP 层解析接收端链路层接收数据包，校验 MAC 地址匹配后剥离 MAC 首部，传递给 IP 层；IP 层校验 IP 地址和校验和，剥离 IP 首部，将 TCP 包传递给 TCP 层。步骤 2：TCP 层校验与处理校验 TCP 校验和，若损坏则丢弃；检查端口号，将包转发到对应应用程序的socket；根据标志位和序号处理：若为 SYN 包（连接请求），回复 SYN+ACK 包（确认连接）；若为数据 + ACK 包，检查序号是否连续，重组数据后通知应用层，并回复 ACK 确认；若为 FIN 包（关闭请求），回复 ACK 确认，随后发起自己的 FIN 包。步骤 3：应用层接收数据TCP 层将重组后的完整数据传递给应用层（如浏览器解析 HTTP 响应）。\n\n\n三、基于 TCP 标志位的常见扫描原理（Nmap 为例）扫描的核心是发送特定标志位的 TCP 包，通过接收端的响应推断端口状态（开放 &#x2F; 关闭 &#x2F; 过滤），以下是典型场景：\n\n全连接扫描（-sT）：模拟正常连接发包逻辑：完成完整三次握手。扫描端 → 目标端口：SYN 包（标志位：SYN&#x3D;1）；目标端口开放 → 扫描端：SYN+ACK 包（SYN&#x3D;1，ACK&#x3D;1）；扫描端 → 目标端口：ACK 包（ACK&#x3D;1），建立连接后主动发送FIN 包关闭。响应判断：收到 SYN+ACK → 端口开放；收到 RST 包 → 端口关闭；无响应 → 可能被防火墙过滤。\nSYN 半开放扫描（-sS）：隐蔽扫描发包逻辑：不完成三次握手，减少日志记录。扫描端 → 目标端口：SYN 包；目标端口开放 → 扫描端：SYN+ACK 包；扫描端 → 目标端口：RST 包（直接断开，不建立连接）。响应判断：同全连接扫描，但目标日志可能不记录完整连接。\nACK 扫描（-sA）：探测防火墙规则发包逻辑：发送无 SYN 的 ACK 包（仅 ACK&#x3D;1）。响应判断：收到 RST 包 → 防火墙未过滤该端口（目标直接回复 RST）；无响应 → 防火墙过滤了该包（如状态检测防火墙拦截 “无连接上下文的 ACK 包”）。\nFIN 扫描（-sF）：利用操作系统差异发包逻辑：发送仅含 FIN 标志位的包（用于终止连接的标志）。响应判断（依赖操作系统实现）：收到 RST 包 → 端口关闭（多数系统对关闭端口的 FIN 包回复 RST）；无响应 → 端口开放（开放端口通常忽略未建立连接的 FIN 包）或被过滤。\nXMAS 扫描（-sX）与 NULL 扫描（-sN）：异常包探测XMAS 扫描：发送 FIN+PSH+URG 包（标志位全 1，类似 “亮灯”）；NULL 扫描：发送无任何标志位的包（标志位全 0）。响应判断：同 FIN 扫描，但仅对遵循 RFC 标准的系统（如 Linux）有效，Windows 系统可能不按此规则响应（会对 NULL 包回复 RST）。\n\n\n总结TCP 的发包与解包依赖协议栈对首部字段（尤其是标志位、序号）的处理，而扫描本质是通过 “主动发送特定标志位的包” 触发目标的标准化响应，进而推断网络状态。不同扫描类型的核心差异在于标志位组合和是否遵循正常连接流程，隐蔽性（如 SYN 扫描）和准确性（如全连接扫描）各有侧重。\n","slug":"TCP协议基础","date":"2025-10-16T09:47:31.000Z","categories_index":"","tags_index":"-network","author_index":"Wclxd"},{"id":"a03a11a291d2e8cc2f6b77138205211d","title":"使用Nmap对防火墙和IDS/IPS 规避","content":"防火墙防火墙是一种防止外部网络进行未经授权连接尝试的安全措施。每个防火墙安全系统都基于一个软件组件，该组件监控防火墙与传入数据连接之间的网络流量，并根据已设置的规则决定如何处理连接。它检查单个网络包是否被传递、忽略或阻止。这种机制旨在防止可能危险的不受欢迎的连接。\nIDS&#x2F;IPSIDSIntrusion Detection System是一种基于软件（或软硬件结合）的网络安全组件，核心功能是监控与报警\nIPSIntrusion Prevention System，对 IDS 功能的补充和升级，核心功能是检测与拦截\n","slug":"使用Nmap对防火墙和IDS/IPS 规避","date":"2025-10-16T09:47:31.000Z","categories_index":"","tags_index":"tools","author_index":"Wclxd"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2025-10-11T10:02:05.026Z","categories_index":"","tags_index":"","author_index":"Wclxd"}]